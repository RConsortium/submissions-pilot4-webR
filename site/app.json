[{"name":"app.R","content":"library(shiny)\nlibrary(markdown)\n\n# TealShim\nlibrary(R6)\nlibrary(formatters)\n\n# user_guide\nlibrary(reactable)\nlibrary(tibble)\n\n# demographic_table\nlibrary(rtables)\nlibrary(stats)\n\n# km_plot\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(visR)\n\n# primary_table\nlibrary(Tplyr)\nlibrary(huxtable)\nlibrary(tidyr)\nlibrary(glue)\nlibrary(purrr)\nlibrary(stringr)\n\n# efficacy_table\nlibrary(emmeans)\nlibrary(graphics)\nlibrary(tippy)\n\n# completion_table\n##\n\n# adam_data\nlibrary(haven)\n\nbox::use(\n  logic / adam_data[get_adsl, get_adas, get_adtte, get_adlb],\n  views / user_guide,\n  views / demographic_table,\n  views / km_plot,\n  views / primary_table,\n  views / efficacy_table,\n  views / completion_table\n)\n\nadsl <- get_adsl()\nadas <- get_adas()\nadtte <- get_adtte()\nadlb <- get_adlb()\n\nTealShim <- R6::R6Class(\n  \"TealShim\",\n  public = list(\n    initialize = function(adsl, adas, adtte, adlb) {\n      private$data$adsl <- adsl\n      private$data$adas <- adas\n      private$data$adtte <- adtte\n      private$data$adlb <- adlb\n    },\n    get_data = function(name, ...) {\n      switch(name,\n        ADSL = private$data$adsl,\n        ADAS = private$data$adas,\n        ADTTE = private$data$adtte,\n        ADLB = private$data$adlb\n      )\n    },\n    get_varlabels = function(name, cols) {\n      formatters::var_labels(self$get_data(name))[cols]\n    },\n    get_filter_state = function() {\n      c()\n    }\n  ),\n  private = list(\n    data = NULL\n  )\n)\ndatasets <- datasets_km <- TealShim$new(adsl, adas, adtte, adlb)\n\nif (file.exists(\"www/static/about.md\")) {\n  md_path <- \"www/static/about.md\"\n} else {\n  md_path <- tempfile(fileext = \".md\")\n  download.file(\"/static/about.md\", destfile = md_path, mode = \"wb\")\n}\napp_information <- includeMarkdown(md_path)\n\nget_page_dependencies <- function() {\n  tagList(\n    tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"/static/css/styles.css\"),\n    tags$script(src = \"/static/js/scripts.js\"),\n  )\n}\n\nget_page_header <- function() {\n  tags$header(\n    tags$div(\n      class = \"app-header flex\",\n\n      tags$h1(\n        \"Pilot 2 Shiny Application\",\n        tags$span(\n          class = \"text-muted text-smaller text-italic\",\n          \"(using webR framework)\"\n        )\n      ),\n      tags$div(\n        class = \"logos-wrapper\",\n        tags$div(\n          class = \"center-wrap\",\n          actionButton(\n            \"theme_mode_toggle\",\n            class = \"color-mode-toggle\",\n            label = tagList(\n              tags$span(\n                class = \"color-mode dark\",\n                title = \"Switch to light mode\",\n                \"â˜€ï¸\"\n              ),\n              tags$span(\n                class = \"color-mode light\",\n                title = \"Switch to light mode\",\n                \"ðŸŒ‘\"\n              )\n            )\n          ),\n          tags$a(\n            href = \"https://rconsortium.github.io/submissions-wg/\",\n            target = \"_blank\",\n            tags$img(class = \"logo\", src = \"/static/logos/rconsortium.svg\")\n          )\n        )\n      )\n    )\n  )\n}\n\nget_page_footer <- function() {\n  tags$div(\n    class = \"app-footer\",\n\n    tags$p(\n      class = \"text-muted\",\n      \"Source: R Consortium. Adapted to a webR application by Appsilon.\"\n    ),\n    tags$div(\n      class = \"logos-wrapper\",\n      tags$a(\n        href = \"https://rconsortium.github.io/submissions-wg/\",\n        target = \"_blank\",\n        tags$img(class = \"logo\", src = \"/static/logos/rconsortium.svg\")\n      ),\n      tags$a(\n        href = \"https://appsilon.com\",\n        target = \"_blank\",\n        tags$img(class = \"logo\", src = \"/static/logos/appsilon.svg\")\n      )\n    )\n  )\n}\n\nui <- fluidPage(\n  get_page_dependencies(),\n  title = \"Pilot 2 Shiny webR Application\",\n  class = \"app-wrapper dark color-mode\",\n\n  get_page_header(),\n\n  tabsetPanel(\n    id = \"moduleTabs\",\n    type = \"tabs\",\n\n    tabPanel(\"App Information\", app_information),\n    tabPanel(\"User Guide\", user_guide$ui(\"user_guide\", datasets)),\n    tabPanel(\"Demographic Table\",\n      demographic_table$ui(\"demographic_table\", datasets)\n    ),\n    tabPanel(\"KM Plot for TTDE\", km_plot$ui(\"km_plot\", datasets)) |>\n      tagAppendAttributes(class = \"no-background-tab\"),\n    tabPanel(\"Primary Table\", primary_table$ui(\"primary_table\", datasets)),\n    tabPanel(\"Efficacy Table\", efficacy_table$ui(\"efficacy_table\", datasets)),\n    tabPanel(\"Visit Completion Table\",\n      completion_table$ui(\"visit_completion_table\", datasets)\n    )\n  ),\n\n  get_page_footer()\n)\n\nserver <- function(input, output, session) {\n  moduleServer(\"user_guide\",\n    function(input, output, session) {\n      user_guide$server(input, output, session, datasets)\n    }\n  )\n  moduleServer(\"demographic_table\",\n    function(input, output, session) {\n      demographic_table$server(input, output, session, datasets)\n    }\n  )\n  moduleServer(\"km_plot\",\n    function(input, output, session) {\n      km_plot$server(input, output, session, datasets)\n    }\n  )\n  moduleServer(\"primary_table\",\n    function(input, output, session) {\n      primary_table$server(input, output, session, datasets)\n    }\n  )\n  moduleServer(\"efficacy_table\",\n    function(input, output, session) {\n      efficacy_table$server(input, output, session, datasets)\n    }\n  )\n  moduleServer(\"visit_completion_table\",\n    function(input, output, session) {\n      completion_table$server(input, output, session, datasets)\n    }\n  )\n\n  observe({\n    session$sendCustomMessage(\"toggle_dark\", input$theme_mode_toggle)\n  }) |>\n  bindEvent(input$theme_mode_toggle, once = FALSE, ignoreInit = TRUE)\n}\n\nshinyApp(ui, server)\n","type":"text"},{"name":"logic/Tplyr_helpers.R","content":"box::use(\n  dplyr[across, starts_with, arrange, mutate, bind_rows, select, distinct, rename],\n  tidyr[replace_na],\n)\n\n#' Nest Row Labels in a Tplyr table\n#'\n#' This is a (high ungeneralized) helper function. Current function assumes that\n#' row_label1 groups row_label2, and turns row_label1 into a stub over its\n#' related groups of row_label2.\n#'\n#' @param .dat Input data set - should come from a built Tplyr table.\n#'\n#' @return data.frame with row labels nested\n#' @export\nnest_rowlabels <- function(.dat) {\n  stubs <- .dat |>\n    distinct(row_label1, ord_layer_index) |>\n    rename(row_label = row_label1) |>\n    mutate(\n      ord_layer_1 = 0,\n      ord_layer_2 = 0\n    )\n\n  .dat |>\n    select(-row_label1, row_label = row_label2) |>\n    bind_rows(stubs) |>\n    arrange(ord_layer_index, ord_layer_1, ord_layer_2) |>\n    mutate(\n      across(starts_with(\"var\"), ~ replace_na(., \"\"))\n    )\n}\n","type":"text"},{"name":"logic/adam_data.R","content":"box::use(\n  # config[get],\n  haven[read_xpt],\n  dplyr[mutate, filter, select],\n  utils[download.file]\n)\n\nget_file <- function(url) {\n  if (file.exists(paste0(\"www/\", url))) {\n    xpt_path <- paste0(\"www/\", url)\n  } else {\n    xpt_path <- tempfile(fileext = \".xpt\")\n    download.file(paste0(\"/\", url), destfile = xpt_path, mode = \"wb\")\n  }\n\n  read_xpt(xpt_path)\n}\n\n#' @export\nget_adsl <- function() {\n  get_file(\"adam/adsl.xpt\") |>\n  # read_xpt(file.path(\"adam\", \"adsl.xpt\")) |>\n    mutate(\n      TRT01P = factor(TRT01P, levels = c(\"Placebo\", \"Xanomeline Low Dose\", \"Xanomeline High Dose\")),\n      AGEGR1 = factor(AGEGR1, levels = c(\"<65\", \"65-80\", \">80\")),\n      RACE = factor(\n        RACE,\n        levels = c(\"WHITE\", \"BLACK OR AFRICAN AMERICAN\", \"AMERICAN INDIAN OR ALASKA NATIVE\")\n      )\n    )\n}\n\n#' @export\nget_adas <- function() {\n  get_file(\"adam/adadas.xpt\") |>\n  # read_xpt(file.path(\"adam\", \"adadas.xpt\")) |>\n    filter(\n      EFFFL == \"Y\",\n      ITTFL == \"Y\",\n      PARAMCD == \"ACTOT\",\n      ANL01FL == \"Y\"\n    )\n}\n\n#' @export\nget_adtte <- function() {\n  get_file(\"adam/adtte.xpt\") |>\n  # read_xpt(file.path(\"adam\", \"adtte.xpt\")) |>\n    filter(PARAMCD == \"TTDE\") |>\n    select(-c(TRTDUR, TRTP, TRTA, TRTAN))\n}\n\n#' @export\nget_adlb <- function() {\n  get_file(\"adam/adlbc.xpt\") |>\n  # read_xpt(file.path(\"adam\", \"adlbc.xpt\")) |>\n    filter(PARAMCD == \"GLUC\" & !is.na(AVISITN))\n}\n","type":"text"},{"name":"logic/eff_models.R","content":"box::use(\n  dplyr[arrange, bind_rows, case_when, filter, mutate, rowwise, select],\n  emmeans[contrast, lsmeans],\n  glue[glue],\n  stats[confint, drop1, lm],\n  tibble[as_tibble, tibble],\n  tidyr[pivot_longer],\n)\n\nbox::use(\n  .. / logic / helpers[pad_row, num_fmt],\n)\n\n#' ANCOVA Model data processing necessary for Table 14-3.01\n#'\n#' This function handles the necessary data processing to handle the CDISC pilot\n#' primary endpoint analysis. The original source can be found\n#' [here](https://github.com/atorus-research/CDISC_pilot_replication/blob/3c8e9e3798c02be8d93bd8e8944d1e0d3f6519e2/programs/funcs.R#L401) #nolint\n#'\n#' @param data Source dataset (filtered by flags)\n#' @param var Variable on which model should be run\n#' @param wk Visit to be modeled\n#' @param show_pvalue Indicator to display p-values in table\n#'\n#' @return Formatted dataframe\n#'\n#' @export\n#'\nefficacy_models <- function(data, var = NULL, wk = NULL, show_pvalue = TRUE) {\n  # Need to set contrasts to work for Type III SS. See analysis results metadata for\n  # table 14-3.01. Reference for R here: https://www.r-bloggers.com/anova-%E2%80%93-type-iiiiii-ss-explained/  #nolint\n  op <- options(contrasts = c(\"contr.sum\", \"contr.poly\"))\n\n  # Subset to analyze\n  data <- data |>\n    filter(AVISITN == wk)\n\n  data <- data |>\n    mutate(\n      TRTPCD = case_when(\n        TRTPN == 0 ~ \"Pbo\",\n        TRTPN == 54 ~ \"Xan_Lo\",\n        TRTPN == 81 ~ \"Xan_Hi\"\n      )\n    )\n\n  # Create an ordered factor variable for the models\n  data[\"TRTPCD_F\"] <- factor(data$TRTPCD, levels = c(\"Xan_Hi\", \"Xan_Lo\", \"Pbo\"))\n  data[\"AWEEKC\"] <- factor(data$AVISIT)\n\n  # Set up the models\n  if (var == \"CHG\") {\n    model1 <- lm(CHG ~ TRTPN + SITEGR1 + BASE, data = data)\n    model2 <- lm(CHG ~ TRTPCD_F + SITEGR1 + BASE, data = data)\n  } else {\n    model1 <- lm(AVAL ~ TRTPN + SITEGR1, data = data)\n    model2 <- lm(AVAL ~ TRTPCD_F + SITEGR1, data = data)\n  }\n\n  ## Dose Response --- NOTE: For statistics portions, I purposefully did not\n  # import the libraries to make it explicitly clear which packages were being\n  # used to match P-values.\n  ancova <- drop1(model1, . ~ ., test = \"F\")\n\n  # Pull it out into a table\n  sect1 <- tibble(\n    row_label = c(\"p-value(Dose Response) [1][2]\"),\n    `81` = ifelse(\n      show_pvalue,\n      c(num_fmt(ancova[2, \"Pr(>F)\"], int_len = 4, digits = 3, size = 12)),\n      \"Not Applicable\"\n    )\n  ) |>\n    pad_row()\n\n  ## Pairwise Comparisons ----\n  # Here's a reference for the emmeans package and how to use it:\n  #   https://cran.r-project.org/web/packages/emmeans/vignettes/confidence-intervals.html\n  # Adjustments made are in line with the analysis results metadata in the analysis define\n  # and PROC GLM documentation.\n\n  # Linear model but use treatment group as a factor now\n  # LS Means and weight proportionately to match OM option on PROC GLM in SAS\n  lsm <- lsmeans(model2, ~TRTPCD_F, weights = \"proportional\")\n\n  # Here on out - it's all the same data manipulation\n  # Get pairwise contrast and remove P-values adjustment for multiple groups\n  cntrst_p <- contrast(lsm, method = \"pairwise\", adjust = NULL)\n  # 95% CI\n  cntrst_ci <- confint(cntrst_p)\n\n  # merge and convert into dataframe\n  pw_data <- as_tibble(summary(cntrst_p)) |>\n    merge(as_tibble(cntrst_ci)) |>\n    rowwise() |>\n    # Create the display strings\n    mutate(\n      p = ifelse(\n        show_pvalue,\n        num_fmt(p.value, int_len = 4, digits = 3, size = 12),\n        \"Not Applicable\"\n      ),\n      diff_se = as.character(\n        glue(\n          \"{num_fmt(estimate, int_len=2, digits=1, size=4)}\n          ({num_fmt(SE, int_len=1, digits=2, size=4)})\"\n        )\n      ),\n      ci = as.character(\n        glue(\n          \"({num_fmt(lower.CL, int_len=2, digits=1, size=4)};\n          {num_fmt(upper.CL, int_len=1, digits=1, size=3)})\"\n        )\n      )\n    ) |>\n    # Clean out the numeric variables\n    select(contrast, p, diff_se, ci) |>\n    # Transpose\n    pivot_longer(c(\"p\", \"diff_se\", \"ci\"), names_to = \"row_label\")\n\n  # Subset Xan_Lo - Pbo into table variables\n  xan_lo <- pw_data |>\n    filter(contrast == \"Xan_Lo - Pbo\") |>\n    # Rename to the table display variable\n    select(`54` = value) |>\n    pad_row()\n\n  # Add in row_label\n  xan_lo[\"row_label\"] <- c(\n    \"p-value(Xan - Placebo) [1][3]\", \"  Diff of LS Means (SE)\", \"  95% CI\", \"\"\n  )\n\n  # Subset Xan_hi - Pbo into table variables\n  xan_hi <- pw_data |>\n    filter(contrast == \"Xan_Hi - Pbo\") |>\n    # Rename to the table display variable\n    select(`81` = value) |>\n    pad_row()\n  # Add in row_label\n  xan_hi[\"row_label\"] <- c(\n    \"p-value(Xan - Placebo) [1][3]\", \"  Diff of LS Means (SE)\", \"  95% CI\", \"\"\n  )\n  xan_hi[\"ord\"] <- c(1, 2, 3, 4) # Order for sorting\n\n  # Subset Xan_Hi - Xan_Lo into table variable\n  xan_xan <- pw_data |>\n    filter(contrast == \"Xan_Hi - Xan_Lo\") |>\n    # Rename to the table display variable\n    select(`81` = value)\n  # Add in row_label\n  xan_xan[\"row_label\"] <- c(\n    \"p-value(Xan High - Xan Low) [1][3]\", \"  Diff of LS Means (SE)\", \"  95% CI\"\n  )\n  xan_xan[\"ord\"] <- c(5, 6, 7) # Order for sorting\n\n  # Pack it all together\n  pw_final <- merge(xan_lo, xan_hi, by = \"row_label\") |>\n    bind_rows(xan_xan) |>\n    arrange(ord)\n\n  # Bind and clean up\n  bind_rows(sect1, pw_final) |>\n    select(row_label,\n      `var1_Xanomeline Low Dose` = `54`,\n      `var1_Xanomeline High Dose` = `81`\n    )\n}\n","type":"text"},{"name":"logic/formatters.R","content":"#' Format numeric value\n#'\n#' @examples\n#' fmt_num(1.25, digits = 1)\n#' @export\nfmt_num <- function(x, digits, width = digits + 4) {\n  formatC(x,\n    digits = digits,\n    format = \"f\",\n    width = width\n  )\n}\n\n#' Format point estimator\n#'\n#' @param .mean mean of an estimator.\n#' @param .sd sd of an estimator.\n#' @param digits number of digits for `.mean` and `.sd`.\n#'\n#' @examples\n#' fmt_est(1.25, 0.5)\n#' @export\nfmt_est <- function(.mean,\n                    .sd,\n                    digits = c(1, 2)) {\n  .mean <- fmt_num(.mean, digits[1], width = digits[1] + 4)\n  .sd <- fmt_num(.sd, digits[2], width = digits[2] + 3)\n  paste0(.mean, \" (\", .sd, \")\")\n}\n\n#' Format confidence interval\n#'\n#' @param .est an estimator.\n#' @param .lower lower confidence interval bound of an estimator.\n#' @param .upper upper confidence interval bound of an estimator.\n#' @param digits number of digits for `.est`, `.lower`, and `.upper`.\n#' @param width the total field width.\n#'\n#' @examples\n#' fmt_ci(1, -0.25, 1.32)\n#' @export\nfmt_ci <- function(.est,\n                   .lower,\n                   .upper,\n                   digits = 2,\n                   width = digits + 3) {\n  .est <- fmt_num(.est, digits, width)\n  .lower <- fmt_num(.lower, digits, width)\n  .upper <- fmt_num(.upper, digits, width)\n  paste0(.est, \" (\", .lower, \",\", .upper, \")\")\n}\n\n#' Format p-Value\n#'\n#' @param .p a p-value.\n#' @param digits number of digits for `.est`, `.lower`, and `.upper`.\n#'\n#' @examples\n#' fmt_pval(0.2)\n#' @export\nfmt_pval <- function(.p, digits = 3) {\n  scale <- 10^(-1 * digits)\n  p_scale <- paste0(\"<\", digits)\n  ifelse(.p < scale, p_scale, fmt_num(.p, digits = digits))\n}\n","type":"text"},{"name":"logic/helpers.R","content":"box::use(\n  glue[glue],\n  purrr[map_lgl],\n  rtables[nrow],\n  stringr[str_pad],\n)\n\n#' Add a padding row below data\n#'\n#' @param .data Data to pad\n#' @param n Number of rows to pad\n#'\n#' @return Dataframe with extra blank rows\n#' @export\npad_row <- function(.data, n = 1) {\n  .data[(nrow(.data) + 1):(nrow(.data) + n), ] <- \"\"\n  .data\n}\n\n#' Number formatter\n#'\n#' Format numbers for presentation, with proper rounding of data\n#'\n#' @param var Variable to format\n#' @param digits Desired number of decimal places\n#' @param size String size\n#' @param int_len Space allotted for integer side of the decimal\n#'\n#' @return Formatted string\n#' @export\nnum_fmt <- Vectorize(function(var, digits = 0, size = 10, int_len = 3) {\n  # Formats summary stat strings to align display correctly\n\n  if (is.na(var)) {\n    return(\"\")\n  }\n\n  # Set nsmall to input digits\n  nsmall <- digits\n\n  # Incremement digits for to compensate for display\n  if (digits > 0) {\n    digits <- digits + 1\n  }\n\n  # Form the string\n  return(str_pad(\n    format(\n      # Round\n      round(var, nsmall),\n      # Set width of format string\n      width = (int_len + digits),\n      # Decimals to display\n      nsmall = nsmall\n    ),\n    # Overall width padding\n    side = \"right\", size\n  ))\n})\n\n#' style a tooltip produced by the tippy package\n#'\n#' @param text String for text in tooltip\n#' @param font_size Font size (in pixels)\n#'\n#' @return HTML with font size applied\n#' @export\ntooltip_text <- function(text, font_size = 16) {\n  glue(\"<span style='font-size:{font_size}px;'>{text}<span>\")\n}\n\n#' check if a filter is active in a teal module\n#'\n#' @param datasets instance of teal filtered datasets class\n#'\n#' @return boolean, TRUE if a filter is applied, FALSE otherwise\n#' @export\nfilter_active <- function(datasets) {\n  result <- FALSE\n  if (length(names(datasets$get_filter_state()) > 0)) {\n    filter_use <- map_lgl(names(datasets$get_filter_state()), ~ {\n      # grab call of filter code\n      f_call <- datasets$get_call(.x)$filter\n      f_call != glue(\"{.x}_FILTERED <- {.x}\")\n    })\n    result <- any(filter_use)\n  }\n\n  return(result)\n}\n","type":"text"},{"name":"logic/kmplot_helpers.R","content":"box::use(\n  cowplot[plot_grid],\n  dplyr[desc, intersect],\n  ggplot2[\n    aes, element_blank, element_text, geom_text, ggplot, ggplot_build,\n    ggtitle, scale_x_continuous, theme, theme_bw, unit, xlab, ylab\n  ],\n  stats[reorder],\n  # teal.data[get_labels],\n  visR[align_plots, get_risktable],\n)\n\nget_labels <- function(data, fill = TRUE) {\n  stopifnot(is.data.frame(data))\n  checkmate::assert_flag(fill)\n\n  column_labels <- Map(function(col, colname) {\n    label <- attr(col, \"label\")\n    if (is.null(label)) {\n      if (fill) {\n        colname\n      } else {\n        NA_character_\n      }\n    } else {\n      if (!checkmate::test_string(label, na.ok = TRUE)) {\n        stop(\"label for variable \", colname, \" is not a character string\")\n      }\n      as.vector(label) # because label might be a named vector\n    }\n  }, data, colnames(data))\n  column_labels <- unlist(column_labels, recursive = FALSE, use.names = TRUE)\n\n  list(\"dataset_label\" = data_label(data), \"column_labels\" = column_labels)\n}\n\n#' @export\nadd_risktable2 <- function(gg,\n                           times = NULL,\n                           statlist = \"n.risk\",\n                           label = NULL,\n                           group = \"strata\",\n                           collapse = FALSE,\n                           rowgutter = .16,\n                           risk_font_size = 6.0,\n                           risk_label_font_size = 12,\n                           ...) {\n  if (!(is.numeric(rowgutter) == TRUE) || (rowgutter < 0) || (rowgutter > 1)) {\n    stop(\"rowgutter should be a numeric value in range [0, 1]\")\n  }\n\n  tidy_object <- gg$data\n  estimate_object <- visR:::.extract_estimate_object(gg)\n\n  ggbld <- ggplot_build(gg)\n\n  graphtimes <- as.numeric(ggbld$layout$panel_params[[1]]$x$get_labels())\n\n  if (is.null(times)) times <- graphtimes\n\n  final <-\n    get_risktable(estimate_object,\n      times = times,\n      statlist = statlist,\n      label = label,\n      group = group,\n      collapse = collapse\n    )\n\n  times <- as.numeric(unique(final$time))\n  statlist <- attributes(final)$statlist\n  title <- attributes(final)$title\n\n  attr(final, \"time_ticks\") <- NULL\n  attr(final, \"statlist\") <- NULL\n  attr(final, \"title\") <- NULL\n\n  tbls <- Map(\n    function(statlist, title = NA) {\n      ggrisk <- ggplot(\n        final,\n        aes(\n          x = time,\n          y = reorder(y_values, desc(y_values)),\n          label = format(get(statlist), nsmall = 0)\n        )\n      ) +\n        geom_text(size = risk_font_size, hjust = 0.5, vjust = 0.5, angle = 0, show.legend = FALSE) +\n        theme_bw() +\n        scale_x_continuous(\n          breaks = graphtimes,\n          limits = c(min(graphtimes), max(graphtimes))\n        ) +\n        theme(\n          axis.title.x = element_text(\n            size = 8,\n            vjust = 1,\n            hjust = 1\n          ),\n          panel.grid.major = element_blank(),\n          panel.grid.minor = element_blank(),\n          panel.border = element_blank(),\n          axis.line = element_blank(),\n          axis.text.x = element_blank(),\n          axis.ticks = element_blank(),\n          axis.text.y = element_text(size = risk_label_font_size, colour = \"black\", face = \"plain\"),\n          plot.margin = unit(c(1, 0, 0, 0), \"lines\"),\n          plot.title = element_text(hjust = 0, vjust = 0),\n          legend.position = \"none\"\n        ) +\n        xlab(NULL) +\n        ylab(NULL)\n\n      if (!is.na(title) && !is.null(title)) {\n        ggrisk <- ggrisk +\n          ggtitle(title) +\n          theme(plot.title = element_text(size = 10))\n      }\n\n      return(ggrisk)\n    },\n    statlist = as.list(statlist),\n    title = as.list(title)\n  )\n\n  gglist <- list(gg) |>\n    append(tbls)\n\n  gg_a <- gglist |>\n    align_plots()\n\n  gg_b <- plot_grid(\n    plotlist = gg_a,\n    align = \"none\",\n    nrow = length(gg_a),\n    rel_heights = c(1 - (rowgutter * (length(gg_a) - 1)), rep(rowgutter, length(gg_a) - 1))\n  )\n\n  class(gg_b) <- c(class(gg_b), intersect(class(gg), c(\"ggsurvfit\", \"ggtidycmprsk\")))\n\n  components <- append(list(gg), tbls)\n  names(components) <- c(\"visR_plot\", title)\n  gg_b[[\"components\"]] <- components\n\n  return(gg_b)\n}\n","type":"text"},{"name":"views/completion_table.R","content":"box::use(\n  Tplyr[\n    add_column_headers, add_layer, add_total_group, build, f_str,\n    group_count, header_n, set_distinct_by, set_format_strings,\n    set_pop_data, set_pop_treat_var, tplyr_table\n  ],\n  dplyr[distinct, filter, left_join, mutate, select, tibble],\n  huxtable[\n    as_hux, set_align, set_bold, set_bottom_border,\n    set_col_width, set_escape_contents, set_valign, set_width, to_html\n  ],\n  rtables[ncol],\n  shiny[HTML, NS, p, renderUI, tagList, uiOutput],\n)\n\n#' @export\nui <- function(id, datasets) {\n  ns <- NS(id)\n  tagList(\n    uiOutput(ns(\"table\")),\n    p(\"Table is based on participants within the ITT population\")\n  )\n}\n\n#' @export\nserver <- function(input, output, session, datasets) {\n  output$table <- renderUI({\n    filtered_adsl <- datasets$get_data(\"ADSL\", filtered = FALSE)\n    filtered_adlb <- datasets$get_data(\"ADLB\", filtered = FALSE)\n    adsl <- filtered_adsl\n    adlbc <- filtered_adlb\n\n    # use adlbc data set to remain consistent with efficacy table input data\n    visit_df <- adlbc |>\n      filter(PARAMCD == \"GLUC\") |>\n      filter(AVISITN != 98) |>\n      filter(!is.na(AVISITN)) |>\n      select(USUBJID, AVISITN) |>\n      distinct() |>\n      left_join(\n        select(adsl, USUBJID, TRT01P),\n        by = \"USUBJID\"\n      )\n\n    # visit number and week lookup\n    v_week_df <- tibble(\n      AVISITN = c(0, 2, 4, 6, 8, 12, 16, 20, 24, 26, 99),\n      VISIT = c(\"Baseline \", paste(\"Week\", c(2, 4, 6, 8, 12, 16, 20, 24, 26)), \"End of Treatment\")\n    ) |>\n      mutate(\n        VISIT = factor(\n          VISIT,\n          levels = c(\n            \"Baseline \",\n            paste(\"Week\", c(2, 4, 6, 8, 12, 16, 20, 24, 26)),\n            \"End of Treatment\"\n          )\n        )\n      )\n\n    # build Tplyr table\n    t_visit <- visit_df |>\n      left_join(v_week_df, by = \"AVISITN\") |>\n      tplyr_table(TRT01P) |>\n      set_pop_data(adsl) |>\n      set_pop_treat_var(TRT01P) |>\n      add_total_group() |>\n      add_layer(\n        group_count(VISIT) |>\n          set_distinct_by(USUBJID) |>\n          set_format_strings(\n            f_str(\"xx (xx%)\", distinct_n, distinct_pct)\n          )\n      )\n\n    b_t_visit <- t_visit |>\n      build() |>\n      select(\n        row_label1, var1_Placebo, `var1_Xanomeline High Dose`,\n        `var1_Xanomeline Low Dose`, var1_Total\n      ) |>\n      add_column_headers(\n        paste0(\n          \"|Placebo<\/br>(N=**Placebo**)\",\n          \"| Xanomeline High Dose<\/br>(N=**Xanomeline High Dose**) \",\n          \"| Xanomeline Low Dose<\/br>(N=**Xanomeline Low Dose**) \",\n          \"| Total<\/br>(N=**Total**) \"\n        ),\n        header_n(t_visit)\n      )\n\n    ht <- as_hux(b_t_visit, add_colnames = FALSE) |>\n      set_bold(1, seq_len(ncol(b_t_visit)), TRUE) |>\n      set_align(1, seq_len(ncol(b_t_visit)), \"center\") |>\n      set_valign(1, seq_len(ncol(b_t_visit)), \"bottom\") |>\n      set_bottom_border(1, seq_len(ncol(b_t_visit)), 1) |>\n      set_width(0.9) |>\n      set_escape_contents(FALSE) |>\n      set_col_width(c(.5, 1 / 8, 1 / 8, 1 / 8, 1 / 8))\n    HTML(to_html(ht))\n  })\n}\n","type":"text"},{"name":"views/demographic_table.R","content":"box::use(\n  rtables[\n    add_colcounts, analyze, as_html, basic_table,\n    build_table, in_rows, list_wrap_x, split_cols_by\n  ],\n  shiny[NS, renderUI, uiOutput],\n  stats[median, sd],\n)\n\n#' ui_t_demographic UI Function\n#'\n#' @description A shiny Module.\n#'\n#' @param id,input,output,session Internal parameters for {shiny}.\n#'\n#' @export\nui <- function(id, datasets) {\n  ns <- NS(id)\n  uiOutput(ns(\"table\"), class = \"top-margin\")\n}\n\n#' srv_t_demographic Server Functions\n#'\n#' @export\nserver <- function(input, output, session, datasets) {\n  output$table <- renderUI({\n    if (is.null(datasets)) {\n      return(NULL)\n    }\n\n    filtered_adsl <- datasets$get_data(\"ADSL\", filtered = FALSE)\n    vars <- c(\"AGE\", \"AGEGR1\", \"RACE\", \"HEIGHTBL\", \"WEIGHTBL\", \"BMIBL\")\n    labels <- datasets$get_varlabels(\"ADSL\", vars)\n    labels <- vapply(vars, function(x) {\n      ifelse(is.na(labels[[x]]),\n        x, labels[[x]]\n      )\n    }, character(1))\n    labels[\"AGEGR1\"] <- \"Age group\"\n    labels[\"AGE\"] <- \"Age (year)\"\n    labels[\"RACE\"] <- \"Race\"\n    lyt <- basic_table(\n      title = \"Protocol: CDISCPILOT01\",\n      subtitles = \"Population: Intent-to-Treat\",\n      main_footer = paste0(Sys.time())\n    ) |>\n      split_cols_by(\"TRT01P\") |>\n      add_colcounts() |>\n      analyze(vars, function(x, ...) {\n        if (is.numeric(x)) {\n          in_rows(\n            \"Mean (SD)\" = c(mean(x), sd(x)),\n            \"Median\" = median(x),\n            \"Min - Max\" = range(x),\n            .formats = c(\"xx.xx (xx.xx)\", \"xx.xx\", \"xx.xx - xx.xx\")\n          )\n        } else if (is.factor(x) || is.character(x)) {\n          in_rows(.list = list_wrap_x(table)(x))\n        } else {\n          stop(\"type not supproted\")\n        }\n      },\n      var_labels = labels\n      )\n    tbl <- build_table(lyt, filtered_adsl)\n    as_html(tbl)\n  })\n}\n","type":"text"},{"name":"views/efficacy_table.R","content":"box::use(\n  dplyr[filter, group_by, mutate, n, right_join, select, summarise],\n  emmeans[emmeans],\n  graphics[pairs],\n  purrr[map2],\n  reactable[colDef, colGroup, reactable, reactableOutput, renderReactable],\n  rtables[ncol],\n  shiny[NS, br, column, fluidPage, fluidRow, h4, h6, hr, p, reactive, tags],\n  stats[lm, sd],\n  tippy[tippy],\n)\nbox::use(\n  .. / logic / formatters[fmt_est, fmt_ci, fmt_pval],\n  .. / logic / helpers[tooltip_text, filter_active],\n)\n\n#' @export\nui <- function(id, datasets) {\n  ns <- NS(id)\n  fluidPage(\n    tags$br(),\n    tags$br(),\n    fluidRow(\n      tippy(\n        h4(\"Primary Endpoint Analysis: Glucose (mmol/L) - Summary at Week 20 LOCF\"),\n        tooltip = tooltip_text(\n          \"Table is based on participants who have observable data at Baseline and Week 20\",\n          font_size = 16\n        ),\n        allowHTML = TRUE\n      ),\n      tags$br(), tags$br(),\n      column(\n        width = 10,\n        reactableOutput(ns(\"tbl_efficacy_1\"))\n      )\n    ),\n    tags$br(),\n    tags$br(),\n    tags$hr(),\n    fluidRow(\n      tippy(\n        h4(\"Pairwise Comparison\"),\n        tooltip = tooltip_text(\n          \"Inference in this table is based on a Analysis of Covariance (ANCOVA) model\n          with treatment and baseline value as covariates.\",\n          font_size = 16\n        ),\n        allowHTML = TRUE\n      ),\n      tags$br(),\n      tags$br(),\n      column(\n        width = 10,\n        reactableOutput(ns(\"tbl_efficacy_2\"))\n      )\n    ),\n    tags$br(),\n    tags$br(),\n    tags$hr(),\n    fluidRow(\n      h6(tags$i(\n        \"Abbreviations: CI=Confidence Interval; LS=Least Squares; SD=Standard Deviation\"\n      )),\n      h6(tags$p(\n        \"Table is based on participants who had observable data at Baseline and Week 20\"\n      )),\n      h6(tags$p(\n        \"Based on an Analysis of Covariance (ANCOVA) model\n        with treatment and baseline value as covariates\"\n      ))\n    )\n  )\n}\n\n#' @export\nserver <- function(input, output, session, datasets) {\n  efficacy_results <- reactive({\n    adsl <- datasets$get_data(\"ADSL\", filtered = FALSE)\n\n    itt <- adsl |>\n      filter(ITTFL == \"Y\") |>\n      select(\"STUDYID\", \"USUBJID\")\n\n    adlb <- datasets$get_data(\"ADLB\", filtered = FALSE)\n\n    # prepare labs data for pairwise comparison\n    adlb1 <- adlb |>\n      right_join(itt, by = c(\"STUDYID\", \"USUBJID\")) |>\n      filter(TRTPN %in% c(0, 81), PARAMCD == \"GLUC\", !is.na(AVISITN)) |>\n      mutate(TRTPN = ifelse(TRTPN == 0, 99, TRTPN))\n\n    gluc_lmfit <- lm(\n      CHG ~ BASE + TRTPN,\n      data = adlb1 |>\n        filter(AVISITN == 20)\n    )\n\n    t10 <- adlb1 |>\n      filter(AVISITN == 0) |>\n      group_by(TRTPN, TRTP) |>\n      summarise(\n        N = n(),\n        mean_bl = mean(BASE),\n        sd_bl = sd(BASE)\n      )\n\n    ## Raw summary statistics\n    t11 <- adlb1 |>\n      filter(AVISITN == 20, !is.na(CHG), !is.na(BASE)) |>\n      group_by(TRTPN, TRTP) |>\n      summarise(\n        N_20 = n(),\n        mean_chg = mean(CHG),\n        sd_chg = sd(CHG),\n        mean = mean(AVAL),\n        sd = sd(AVAL)\n      )\n\n    ## Calculate LS mean\n    t12 <- emmeans(gluc_lmfit, \"TRTPN\")\n\n    ## Merge and format data for reporting\n    apr0ancova1 <- merge(t10, t11) |>\n      merge(t12) |>\n      mutate(emmean_sd = SE * sqrt(df)) |>\n      mutate(\n        Trt = c(\"Xanomeline High Dose\", \"Placebo\"),\n        N1 = N,\n        Mean1 = fmt_est(mean_bl, sd_bl),\n        N2 = N_20,\n        Mean2 = fmt_est(mean, sd),\n        N3 = N_20,\n        Mean3 = fmt_est(mean_chg, sd_chg),\n        CI = fmt_ci(emmean, lower.CL, upper.CL)\n      ) |>\n      select(Trt:CI)\n\n    t2 <- data.frame(pairs(t12))\n\n    ## Treatment Comparison\n    apr0ancova2 <- t2 |>\n      mutate(\n        lower = estimate - 1.96 * SE,\n        upper = estimate + 1.96 * SE\n      ) |>\n      mutate(\n        comp = \"Study Drug vs. Placebo\",\n        mean = fmt_ci(estimate, lower, upper),\n        p = ifelse(filter_active(datasets), \"Not Applicable\", fmt_pval(p.value))\n      ) |>\n      select(comp:p)\n\n    ### Calculate root mean square and save data in output folder\n    apr0ancova3 <- data.frame(rmse = paste0(\n      \"Root Mean Squared Error of Change = \",\n      formatC(sqrt(mean((gluc_lmfit$residuals)^2)), digits = 2, format = \"f\", flag = \"0\")\n    ))\n    list(\n      apr0ancova1 = apr0ancova1,\n      apr0ancova2 = apr0ancova2,\n      apr0ancova3 = apr0ancova3\n    )\n  })\n  output$tbl_efficacy_1 <- renderReactable({\n    efficacy_results <- efficacy_results()\n    apr0ancova1 <- efficacy_results$apr0ancova1\n    coln <- c(\n      \"Treatment\",\n      \"N\", \"Mean (SD)\",\n      \"N\", \"Mean (SD)\",\n      \"N\", \"Mean (SD)\", \"LS Mean (95% CI)\"\n    )\n    colgr <- c(1, 2, 2, 3, 3, 4, 4, 4)\n    colwidths <- c(rep(100, 7), 150)\n    colgrn <- c(\"\", \"Baseline\", \"Week 20\", \"Change from Baseline\")\n    collist <- map2(seq_len(ncol(apr0ancova1)), colwidths, ~ {\n      colDef(name = coln[.x], minWidth = .y)\n    })\n    names(collist) <- names(apr0ancova1)\n    reactable(\n      apr0ancova1,\n      columns = collist,\n      columnGroups = list(\n        colGroup(name = colgrn[2], columns = names(apr0ancova1)[colgr == 2]),\n        colGroup(name = colgrn[3], columns = names(apr0ancova1)[colgr == 3]),\n        colGroup(name = colgrn[4], columns = names(apr0ancova1)[colgr == 4])\n      )\n    )\n  })\n  output$tbl_efficacy_2 <- renderReactable({\n    efficacy_results <- efficacy_results()\n    apr0ancova2 <- efficacy_results$apr0ancova2\n    apr0ancova3 <- efficacy_results$apr0ancova3\n    coln <- c(\n      \"\",\n      \"Difference in LS Mean (95% CI)\",\n      \"p-Value\"\n    )\n    collist <- lapply(seq_len(ncol(apr0ancova2)), function(xx) {\n      if (xx > 1) {\n        colDef(name = coln[xx])\n      } else {\n        colDef(name = coln[xx], footer = apr0ancova3$rmse)\n      }\n    })\n    names(collist) <- names(apr0ancova2)\n\n    reactable(\n      apr0ancova2,\n      columns = collist,\n      defaultColDef = colDef(footerStyle = list(fontStyle = \"italic\"))\n    )\n  })\n}\n","type":"text"},{"name":"views/km_plot.R","content":"box::use(\n  dplyr[filter, inner_join, mutate, select],\n  ggplot2[element_text, geom_hline, rel, theme, theme_bw, theme_set],\n  shiny[\n    NS, observeEvent, p, plotOutput, reactiveValues, renderPlot, renderUI, selectInput,\n    tagAppendAttributes, tagList, tags, uiOutput, updateSelectInput,\n    fluidRow, column\n  ],\n  visR[add_CI, add_CNSR, estimate_KM, visr]\n)\n\nbox::use(\n  .. / logic / kmplot_helpers[add_risktable2],\n  . / km_plot_filter\n)\n\nalert_message <- function() {\n  tags$div(\n    class = \"alert alert-info alert-dismissible top-margin top-margin\",\n    style = \"min-height: 100px\",\n\n    tagList(\n      tags$b(\"Important Information:\"),\n      tags$p(\n        \"The analyses performed when utilizing subgroups or\n        other subsets of the source data sets are considered \",\n        tags$b(\"exploratory.\")\n      ),\n      tags$ul(\n        tags$li(\n          \"Treatment information variables from the\",\n          tags$b(\"ADTTE\"),\n          \"data set are excluded from the variable list.\n          Use the treatment variables present in the\",\n          tags$b(\"ADSL\"),\n          \"set to perform treatment-related filters.\"\n        ),\n        tags$li(\n          \"In rare situations, applying filters with variables from both\",\n          tags$b(\"ADSL\"), \"and\", tags$b(\"ADTTE\"),\n          \"that overlap in content could result in an invalid data subset.\n          When possible, select variables with distinct content.\"\n        )\n      )\n    )\n  )\n}\n\n#' @export\nui <- function(id, datasets) {\n  ns <- NS(id)\n\n  fluidRow(\n    column(\n      width = 9,\n\n      tags$div(\n        class = \"background-wrapper\",\n\n        alert_message(),\n        uiOutput(ns(\"plot_title\") ,class = \"plot-message\"),\n        plotOutput(ns(\"plot\"), height = \"600px\"),\n        uiOutput(ns(\"plot_footer\"), class = \"plot-message\")\n      )\n    ),\n    column(\n      width = 3,\n\n      tags$div(\n        class = \"background-wrapper filter-card\",\n        km_plot_filter$ui(ns(\"adsl\"), \"ADSL\")\n      ),\n\n      tags$div(\n        class = \"background-wrapper filter-card\",\n        km_plot_filter$ui(ns(\"adtte\"), \"ADTTE\")\n      )\n    )\n  )\n}\n\n#' @export\nserver <- function(input, output, session, datasets) {\n  adsl_ <- km_plot_filter$server(\"adsl\", \"ADSL\", datasets$get_data(\"ADSL\"))\n  adtte_ <- km_plot_filter$server(\"adtte\", \"ADTTE\", datasets$get_data(\"ADTTE\"))\n\n  output$plot <- renderPlot({\n    adsl <- adsl_()\n    adtte <- adtte_()\n    anl <- adsl |>\n      filter(\n        SAFFL == \"Y\",\n        STUDYID == \"CDISCPILOT01\"\n      ) |>\n      select(STUDYID, USUBJID, TRT01A) |>\n      inner_join(\n        filter(\n          adtte, STUDYID == \"CDISCPILOT01\"\n        ) |> select(STUDYID, USUBJID, AVAL, CNSR, PARAM, PARAMCD),\n        by = c(\"STUDYID\", \"USUBJID\")\n      ) |>\n      mutate(\n        TRT01A = factor(\n          TRT01A,\n          levels = c(\"Placebo\", \"Xanomeline Low Dose\", \"Xanomeline High Dose\")\n        ),\n        AVAL = AVAL / 30.4167\n      )\n\n    surv_mod <- estimate_KM(data = anl, strata = \"TRT01A\")\n    theme_set(theme_bw())\n\n    km_plot <- visr(surv_mod,\n      y_label = \"Survival Probability (%)\",\n      x_label = \"Time (Months)\",\n      fun = \"pct\",\n      legend_position = \"bottom\"\n    ) |>\n      add_CNSR() |>\n      add_CI()\n\n    km_plot <- km_plot +\n      theme(\n        axis.text = element_text(size = rel(1.3)),\n        axis.title = element_text(size = rel(1.4)),\n        legend.text = element_text(size = rel(1.3)),\n        legend.title = element_text(size = rel(1.4))\n      ) +\n      geom_hline(yintercept = 0.5, linetype = \"dashed\")\n\n    km_plot <- km_plot |>\n      add_risktable2(group = \"statlist\")\n\n    output$plot_title <- renderUI({\n      tags$div(\n        style = \"font-weight: bold; font-size: 16px\",\n        \"KM plot for Time to First Dermatologic Event: Safety population\",\n      )\n    })\n\n    output$plot_footer <- renderUI({\n      tagList(\n        tags$div(style = \"font-size: 12px\", \"The shaded areas are 95% CI of the survival probability for each group\"),\n        tags$div(style = \"font-size: 12px\", Sys.time())\n      )\n    })\n\n    km_plot\n  })\n}\n","type":"text"},{"name":"views/km_plot_filter.R","content":"box::use(\n  dplyr[between, filter],\n  ggplot2[aes, geom_density, ggplot, scale_x_continuous, scale_y_continuous, theme_void],\n  grDevices[rgb],\n  purrr[discard, imap, iwalk, reduce, walk],\n  shiny[\n    HTML, NS, bindEvent, dateRangeInput, debounce, isolate, moduleServer, observe, plotOutput,\n    reactive, reactiveVal, reactiveValues, reactiveValuesToList, renderPlot, renderUI, selectInput,\n    sliderInput, tagAppendAttributes, tagList, tags, uiOutput, updateSelectInput\n  ],\n  stats[setNames],\n  tibble[type_sum]\n)\n\nui <- function(id, dataset_name) {\n  ns <- NS(id)\n\n  uiOutput(ns(\"main\")) |>\n    tagAppendAttributes(class = \"km-plot-filters\")\n}\n\nserver <- function(id, dataset_name, dataset) {\n  moduleServer(id, function(input, output, session) {\n    ns <- session$ns\n    filters <- reactiveValues()\n    filters_values <- reactiveValues()\n    filtered_data <- reactiveVal(dataset)\n\n    output$main <- renderUI({\n      choices <- setNames(\n        colnames(dataset),\n        sapply(colnames(dataset), function(col) {\n          col_type <- type_sum(dataset[[col]])\n          sprintf(\"%s (%s)\", col, col_type)\n        })\n      )\n\n      tags$div(\n        tags$h3(\"Add filter variables\"),\n        selectInput(ns(\"variables\"), dataset_name, choices, multiple = TRUE),\n        uiOutput(ns(\"filters\"))\n      )\n    })\n\n    observe({\n      # clean filters that just got disabled\n      setdiff(names(filters), input$variables) |>\n        discard(function(col) is.null(filters[[col]])) |>\n        walk(function(col) {\n          filters[[col]]$obs$destroy()\n          filters[[col]] <- NULL\n          filters_values[[col]] <- NULL\n        })\n\n      # set up filters that just got enabled\n      walk(input$variables, function(col) {\n        if (!is.null(filters[[col]])) { # active filter\n          return()\n        }\n        obs <- observe({\n          filters_values[[col]] <- input[[paste0(\"filter_\", col)]]\n        }) |>\n          bindEvent(input[[paste0(\"filter_\", col)]], ignoreInit = TRUE)\n        values <- switch(type_sum(dataset[[col]]),\n          chr = sort(unique(dataset[[col]])),\n          fct = sort(unique(dataset[[col]])),\n          dbl = range(dataset[[col]]),\n          date = range(dataset[[col]])\n        )\n        filters_values[[col]] <- values\n        filters[[col]] <- list(obs = obs, choices = values)\n      })\n    }) |>\n      bindEvent(input$variables, ignoreNULL = FALSE)\n\n    output$filters <- renderUI({\n      reactiveValuesToList(filters) |>\n        imap(function(meta, col) {\n          if (is.null(meta)) { # filter that was active but is now disabled\n            return(NULL)\n          }\n          values <- isolate(filters_values[[col]])\n          choices <- meta$choices\n          switch(type_sum(dataset[[col]]),\n            chr = selectInput(ns(paste0(\"filter_\", col)), col, choices, values, multiple = TRUE),\n            fct = selectInput(ns(paste0(\"filter_\", col)), col, choices, values, multiple = TRUE),\n            dbl = tags$div(\n              class = \"overlay-slider\",\n              plotOutput(ns(paste0(\"filter_\", col, \"_plot\")), height = \"100%\"),\n              sliderInput(ns(paste0(\"filter_\", col)), col, choices[1], choices[2], values)\n            ),\n            date = dateRangeInput(ns(paste0(\"filter_\", col)), col, choices[1], choices[2], values[1], values[2])\n          )\n        }) |>\n        discard(is.null)\n    })\n\n    observe({\n      reactiveValuesToList(filters) |>\n        iwalk(function(meta, col) {\n          if (is.null(meta) || type_sum(dataset[[col]]) != \"dbl\") {\n            return(NULL)\n          }\n          output[[paste0(\"filter_\", col, \"_plot\")]] <- renderPlot(\n            range_slider_overlay(dataset[[col]]),\n            height = 25,\n            bg = \"transparent\"\n          )\n        })\n    }) |>\n      bindEvent(reactiveValuesToList(filters))\n\n    observe({\n      reactiveValuesToList(filters_values) |>\n        names() |>\n        reduce(.init = dataset, function(df, col) {\n          values <- filters_values[[col]]\n          if (is.null(values) || NROW(df) == 0) {\n            return(df)\n          }\n\n          switch(type_sum(df[[col]]),\n            chr = filter(df, .data[[col]] %in% values),\n            fct = filter(df, .data[[col]] %in% values),\n            dbl = filter(df, between(.data[[col]], values[1], values[2])),\n            date = filter(df, between(.data[[col]], values[1], values[2]))\n          )\n        }) |>\n        filtered_data()\n    }) |>\n      bindEvent(reactiveValuesToList(filters_values))\n\n    return(filtered_data)\n  })\n}\n\nrange_slider_overlay <- function(values) {\n  ggplot(data.frame(x = values), aes(x = x)) +\n    geom_density(\n      fill = rgb(66 / 255, 139 / 255, 202 / 255),\n      color = NA,\n      alpha = 0.2\n    ) +\n    theme_void() +\n    scale_x_continuous(expand = c(0, 0)) +\n    scale_y_continuous(expand = c(0, 0))\n}\n","type":"text"},{"name":"views/primary_table.R","content":"box::use(\n  Tplyr[\n    add_column_headers, add_layer, build, f_str, group_desc, header_n, set_desc_layer_formats,\n    set_distinct_by, set_pop_data, set_pop_treat_var, set_pop_where, tplyr_table\n  ],\n  dplyr[bind_rows, select, starts_with],\n  huxtable[\n    as_hux, set_align, set_bold, set_bottom_border, set_col_width,\n    set_escape_contents, set_valign, set_width, to_html\n  ],\n  rtables[ncol],\n  shiny[HTML, NS, p, renderUI, tagList, uiOutput],\n)\n\nbox::use(\n  .. / logic / eff_models[efficacy_models],\n  .. / logic / Tplyr_helpers[nest_rowlabels],\n  .. / logic / helpers[filter_active],\n)\n\n#' @export\nui <- function(id, datasets) {\n  ns <- NS(id)\n  tagList(\n    uiOutput(ns(\"table\")),\n    p(\n      \"Statistical model and comparison p-values removed when applying data filters.\n      Refer to the application information for additional details.\"\n    ),\n    p(\n      \"[1] Based on Analysis of covariance (ANCOVA) model with treatment and\n      site group as factors and baseline value as a covariate.\"\n    ),\n    p(\n      \"[2] Test for a non-zero coefficient for treatment (dose) as a continuous variable.\"\n    ),\n    p(\n      \"[3] Pairwise comparison with treatment as a categorical variable:\n      p-values without adjustment for multiple comparisons.\"\n    )\n  )\n}\n\n#' @export\nserver <- function(input, output, session, datasets) {\n  output$table <- renderUI({\n    if (is.null(datasets)) {\n      return(NULL)\n    }\n\n    filtered_adsl <- datasets$get_data(\"ADSL\", filtered = FALSE)\n    filtered_adas <- datasets$get_data(\"ADAS\", filtered = FALSE)\n    adas <- filtered_adas\n\n    t <- tplyr_table(adas, TRTP) |>\n      set_pop_data(filtered_adsl) |>\n      set_pop_treat_var(TRT01P) |>\n      set_pop_where(EFFFL == \"Y\" & ITTFL == \"Y\") |>\n      set_distinct_by(USUBJID) |>\n      set_desc_layer_formats(\n        \"n\" = f_str(\"xx\", n),\n        \"Mean (SD)\" = f_str(\"xx.x (xx.xx)\", mean, sd),\n        \"Median (Min; Max)\" = f_str(\"xx.x (xxx;xx)\", median, min, max)\n      ) |>\n      add_layer(\n        group_desc(AVAL, where = AVISITN == 0, by = \"Baseline\")\n      ) |>\n      add_layer(\n        group_desc(AVAL, where = AVISITN == 24, by = \"Week 24\")\n      ) |>\n      add_layer(\n        group_desc(CHG, where = AVISITN == 24, by = \"Change from Baseline\")\n      )\n\n    sum_data <- t |>\n      build() |>\n      nest_rowlabels() |>\n      select(-starts_with(\"ord\")) |>\n      add_column_headers(\n        paste0(\n          \"|Placebo<\/br>(N=**Placebo**)| Xanomeline High Dose<\/br>(N=**Xanomeline High Dose**) \",\n          \"| Xanomeline Low Dose<\/br>(N=**Xanomeline Low Dose**)\"\n        ),\n        header_n(t)\n      )\n    model_portion <- efficacy_models(adas, \"CHG\", 24, !filter_active(datasets))\n\n    final <- bind_rows(sum_data, model_portion)\n\n    ht <- as_hux(final, add_colnames = FALSE) |>\n      set_bold(1, seq_len(ncol(final)), TRUE) |>\n      set_align(1, seq_len(ncol(final)), \"center\") |>\n      set_valign(1, seq_len(ncol(final)), \"bottom\") |>\n      set_bottom_border(1, seq_len(ncol(final)), 1) |>\n      set_width(1) |>\n      set_escape_contents(FALSE) |>\n      set_col_width(c(.5, 1 / 6, 1 / 6, 1 / 6))\n    HTML(to_html(ht))\n  })\n}\n","type":"text"},{"name":"views/user_guide.R","content":"box::use(\n  reactable[reactable, reactableOutput, renderReactable],\n  shiny[\n    NS, br, column, fluidRow, h1, h2, imageOutput,\n    p, renderImage, tabPanel, tabsetPanel, tagList, tags\n  ],\n  tibble[tibble],\n)\n\nui <- function(id, datasets) {\n  ns <- NS(id)\n  tagList(\n    fluidRow(\n      column(\n        width = 12,\n        tags$h1(\"Application Guide\"),\n        tags$p(\n          \"The Pilot 2 Shiny Application contains five distinct interfaces,\n          each displaying a different analysis output as described in the App Information page.\"\n        ),\n        reactableOutput(ns(\"pilot1_table\"))\n      )\n    ),\n    tags$br(),\n    fluidRow(\n      column(\n        width = 12,\n        tags$h2(\"Dynamic Filters\"),\n        tags$p(\n          \"The\", tags$b(\"KM Plot for TTDE\"),\n          \"module allows for filters to be applied based on variables in the\",\n          tags$b(\"ADSL\"), \"and\", tags$b(\"ADTTE\"), \"data sets.\n          Below is an example of performing subpopulation analysis\n          for an age group within the module:\"\n        ),\n        tags$br(),\n        tabsetPanel(\n          id = \"userSteps\",\n          type = \"tabs\",\n          tabPanel(\n            title = \"Step 1\",\n            fluidRow(\n              column(\n                width = 4,\n                tags$img(src = \"/static/app_screenshot1.png\", height = \"auto\")\n              ),\n              column(\n                class = \"top-margin\",\n                width = 8,\n                tags$p(\n                  \"Within the\", tags$b(\"Add Filter Variables\"),\n                  \"widget, click the box with the placeholder\",\n                  tags$b(\"Select variables to filter\")\n                )\n              )\n            )\n          ),\n          tabPanel(\n            title = \"Step 2\",\n            column(\n              width = 4,\n                tags$img(src = \"/static/app_screenshot2.png\", height = \"auto\")\n            ),\n            column(\n              class = \"top-margin\",\n              width = 8,\n              tags$p(\n                \"Scroll up/down or use the search bar to find the variable for subpopulation.\n                Click the desired variable, \",\n                tags$b(\"AGEYR1\"), \"in this example\"\n              )\n            )\n          ),\n          tabPanel(\n            title = \"Step 3\",\n            column(\n              width = 4,\n                tags$img(src = \"/static/app_screenshot3.png\", height = \"auto\")\n            ),\n            column(\n              width = 8,\n              class = \"top-margin\",\n              tags$p(\n                \"In the\", tags$b(\"Active Filter Variables\"),\n                \"widget, the selected variable with its available categories or levels\n                will display,\",\n                tags$b(\"AGEYR1\"), \"in this example, is displayed with three categories.\n                If the selected variable in the previous step is a continuous variable,\n                then a slider will appear for selecting a range of values.\"\n              ),\n              tags$br(),\n              tags$p(\n                \"Select the target subpopulation (e.g. >80) and\n                the analysis output displayed on the left hand side will be updated\n                in real-time according to the selection,\n                which in this example is equivalent to performing a filter on the\",\n                tags$b(\"ADSL\"), \"data by AGEGR1 == '>80'\"\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n}\n\nserver <- function(input, output, session, datasets) {\n  output$pilot1_table <- renderReactable({\n    pilot1_table <- tibble(\n      tab = c(\n        \"Demographic Table\", \"KM Plot for TTDE\",\n        \"Primary Table\", \"Efficacy Table\",\n        \"Visit Completion Table\"\n      ),\n      output = c(\n        \"Table 14-2.01 Summary of Demographic and Baseline Characteristics\",\n        \"Figure 14-1 Time to Dermatologic Event by Treatment Group\",\n        \"Table 14-3.01 Primary Endpoint Analysis: ADAS Cog(11) - Change from Baseline to Week 24 - LOCF\", # nolint\n        \"Table 14-3.02 Primary Endpoint Analysis: Glucose (mmol/L) - Summary at Week 20 - LOCF\",\n        \"Not Applicable\"\n      )\n    )\n\n    reactable(pilot1_table)\n  })\n}\n","type":"text"}]
